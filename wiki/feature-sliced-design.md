# Feature Sliced Design (FSD) в проекте

## Введение

Feature Sliced Design (FSD) — методология проектирования фронтенд-приложений, которая позволяет создавать масштабируемую и поддерживаемую архитектуру. В ее основе лежит разделение кода на слои и модули, что позволяет легко ориентироваться в проекте и развивать его.

## Структура проекта

Архитектура нашего проекта основана на следующих слоях (от верхнего к нижнему):

```
src/
├── app/          # Инициализация приложения, провайдеры
├── pages/        # Страницы приложения
├── widgets/      # Композиционные блоки UI
├── features/     # Интерактивные элементы с бизнес-логикой
├── entities/     # Бизнес-сущности
└── shared/       # Переиспользуемый код
```

### app/

Слой инициализации приложения, содержит:
- `app.tsx` — корневой компонент приложения
- `main.tsx` — точка входа для сборки
- `providers/` — глобальные провайдеры (ErrorBoundary и др.)
- `styles/` — глобальные стили

### pages/

Слой страниц приложения. Каждая страница живет в своей директории:
- `home/` — главная страница портфолио

### widgets/

Слой композиционных блоков, которые объединяют несколько сущностей и фич:
- `portfolio/` — секция с портфолио
- `resume/` — секция с резюме
- `experience/` — секция с опытом работы

### features/

Слой интерактивных элементов с бизнес-логикой:
- `project-modal/` — модальное окно проекта
- `slider/` — слайдер для просмотра проектов

### entities/

Слой бизнес-сущностей приложения:
- `project/` — сущность проекта
- `experience/` — сущность опыта работы

### shared/

Слой переиспользуемого кода, не привязанного к бизнес-логике:
- `api/` — сервисы для работы с данными
- `config/` — константы и конфигурация
- `lib/` — утилиты и хуки
- `ui/` — базовые UI-компоненты
- `model/` — типы и модели данных

## Принципы и правила

### Принцип направленных зависимостей

1. Слой может использовать только нижележащие слои:
   - `pages` может использовать `widgets`, `features`, `entities`, `shared`
   - `widgets` может использовать `features`, `entities`, `shared`
   - `features` может использовать `entities`, `shared`
   - `entities` может использовать только `shared`
   - `shared` не может использовать ни один из вышележащих слоев

2. Слой не может использовать вышележащие слои:
   - `shared` не может использовать `entities`, `features`, `widgets`, `pages`
   - `entities` не может использовать `features`, `widgets`, `pages`
   - И так далее

### Структура сегментов

Каждый сегмент (slice) внутри слоя следует общей структуре:

```
segment/
├── model/     # Логика и типы
├── ui/        # Компоненты React
├── lib/       # Вспомогательные утилиты
├── api/       # API и интеграции
└── index.ts   # Публичное API сегмента
```

### Правила нейминга

1. Директории и файлы:
   - Используйте kebab-case для названий директорий и файлов (`project-modal`, `error-boundary.tsx`)
   - Используйте PascalCase для названий компонентов React (`ProjectModal`)
   - Используйте camelCase для хуков, утилит и других JS функций (`useImageLoad`)

2. Публичное API:
   - Экспортируйте компоненты через индексные файлы
   - Используйте именованные экспорты для всего, кроме компонентов-страниц
   - Страницы экспортируйте как `export default`

### Правила импортов

1. Используйте абсолютные импорты с алиасами для слоев и сегментов:
   ```typescript
   import { ProjectCard } from '@entities/project';
   import { useImageLoad } from '@shared/lib/hooks';
   ```

2. Используйте относительные импорты внутри сегмента:
   ```typescript
   import { ProjectTypes } from '../model/types';
   ```

## Примеры

### Пример сегмента entities

```
src/entities/project/
├── model/
│   ├── types.ts         # Типы и интерфейсы
│   └── store.ts         # Состояние
├── ui/
│   └── project-card.tsx # Компонент карточки проекта
└── index.ts             # Публичное API
```

### Пример API сегмента

```typescript
// src/entities/project/index.ts
export { ProjectCard } from './ui/project-card';
export type { Project, Slide } from './model/types';
```

## Заключение

Feature Sliced Design обеспечивает четкую структуру проекта и разделение ответственности между компонентами. Это делает кодовую базу более понятной, масштабируемой и поддерживаемой в долгосрочной перспективе.

При разработке новых компонентов и фич, следуйте описанным принципам и правилам для сохранения целостности архитектуры.
